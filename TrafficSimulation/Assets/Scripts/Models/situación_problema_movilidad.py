# -*- coding: utf-8 -*-
"""Situación Problema: Movilidad.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HebbWuguduOs1IY4y6SanTeZXBECc-Dw
"""

# matplotlib lo usaremos crear una animación de cada uno de los pasos del modelo.
# %matplotlib inline
import matplotlib
import matplotlib.animation as animation
import matplotlib.pyplot as plt
# Commented out IPython magic to ensure Python compatibility.
# Importamos las clases que se requieren para manejar los agentes (Agent) y su entorno (Model).
# Cada modelo puede contener múltiples agentes.
from mesa import Agent, Model
# Haremos uso de ''DataCollector'' para obtener información de cada paso de la simulación.
from mesa.datacollection import DataCollector
# Debido a que necesitamos que existe un solo agente por celda, elegimos ''SingleGrid''.
from mesa.space import SingleGrid
# Con ''RandomActivation, hacemos que todos los agentes se activen ''al mismo tiempo''.
from mesa.time import SimultaneousActivation

plt.rcParams["animation.html"] = "jshtml"
matplotlib.rcParams['animation.embed_limit'] = 2 ** 128

# Importamos los siguientes paquetes para el mejor manejo de valores numéricos.
import numpy as np

# Definimos otros paquetes que vamos a usar para medir el tiempo de ejecución de nuestro algoritmo.
import time
import datetime

# TC2008B Modelación de Sistemas Multiagentes con gráficas computacionales
# Python server to interact with Unity via POST
# Sergio Ruiz-Loza, Ph.D. March 2021
import json


def get_grid(model):
    # Obtiene el estado de los diferentes agentes
    # On Param - Model: Modelo con la información
    # On Return - Matriz con información sobre el estado de los agentes
    grid = np.zeros((model.grid.width, model.grid.height))
    for (content, x, y) in model.grid.coord_iter():
        if content == None:
            grid[x][y] = 0
        else:
            grid[x][y] = content.car_model
    return grid


class CarAgent(Agent):
    def __init__(self, unique_id, model):
        super().__init__(unique_id, model)
        self.cells_Per_Cycle = 3
        self.car_model = self.random.randrange(50, 255)

    # def seekCollision(self):
    #  surroundings = self.model.grid.get_neighborhood(self.pos, moore=False, include_center=False) # Check the sorrounding tiles for a car
    #  if surroundings != None:
    #    self.speed -= 1
    #  elif self.speed<6:
    #    self.speed += 1

    def seekBorder(self):
        if self.model.grid.out_of_bounds(self.pos):
            self.remove_agent()

    def moveAgent(self):
        if self.cells_Per_Cycle > 0 and self.model.grid.is_cell_empty(self.pos[0] + self.cells_Per_Cycle, self.pos[1]):
            self.model.grid.move_agent(self, (self.pos[0] + self.cells_Per_Cycle, self.pos[1]))

    def step(self):
        self.moveAgent()
        # self.seekCollision()
        self.seekBorder()


class RoadModel(Model):
    # Width: length of the road
    # Height: number or roads
    def __init__(self, width, height):
        self.grid = SingleGrid(width, height, False)  # False stands for not making the grid a Torus
        self.schedule = SimultaneousActivation(self)
        self.running = True
        self.floor = np.zeros((width, height))
        self.car_Counter = 0
        self.active_Cars = []
        self.json = {}

        self.datacollector = DataCollector(model_reporters={"Grid": get_grid})

    def car_Generator(self, lane):
        if self.grid.is_cell_empty((0, lane)):  # Si la celda esta vacia, generar el agente al principio de la
            a = CarAgent(self.car_Counter, self)
            self.car_Counter += 1
            self.grid.position_agent(a, (lane, 0))
            self.schedule.add(a)
            self.active_Cars.append(a)

    def build_JSON(self) -> None:
        for agent in self.active_Cars:
            self.json[agent.unique_id] = {
                "Unique_ID": agent.unique_id,
                "X": agent.pos[0],
                "Y": 0,
                "Z": agent.pos[1],
                "speed": agent.cells_Per_Cycle,
            }

    def getJSON(self):
        return json.dumps(self.json)

    def step(self):
        lane = self.random.randint(0, 2)  # Genera aleatoriamente el carril donde
        # iniciará el auto
        self.car_Generator(lane)
        self.datacollector.collect(self)
        self.build_JSON()


# Definimos el tamaño del Grid
WIDTH = 100  # Longitud de Carriles
HEIGHT = 3  # Carriles

# Definimos el número máximo de generaciones a correr
MAX_GENERATIONS = 10

# Registramos el tiempo de inicio y ejecutamos la simulación
start_time = time.time()
model = RoadModel(HEIGHT, WIDTH)
for i in range(MAX_GENERATIONS):
    model.step()

# Imprimimos el tiempo que le tomó correr al modelo.
print('Tiempo de ejecución:', str(datetime.timedelta(seconds=(time.time() - start_time))))

# Se recupera la información del colector, regresa un Dataframe con la información
all_road = model.datacollector.get_model_vars_dataframe()
all_road_json = model.json
