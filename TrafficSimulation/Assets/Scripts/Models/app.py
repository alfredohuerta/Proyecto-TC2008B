# -*- coding: utf-8 -*-
"""Situación Problema: Movilidad.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HebbWuguduOs1IY4y6SanTeZXBECc-Dw
"""

from flask import Flask

# matplotlib lo usaremos crear una animación de cada uno de los pasos del modelo.
# %matplotlib inline
import matplotlib
import matplotlib.pyplot as plt
# Commented out IPython magic to ensure Python compatibility.
# Importamos las clases que se requieren para manejar los agentes (Agent) y su entorno (Model).
# Cada modelo puede contener múltiples agentes.
from mesa import Agent, Model
# Haremos uso de ''DataCollector'' para obtener información de cada paso de la simulación.
from mesa.datacollection import DataCollector
# Debido a que necesitamos que existe un solo agente por celda, elegimos ''SingleGrid''.
from mesa.space import SingleGrid
# Con ''RandomActivation, hacemos que todos los agentes se activen ''al mismo tiempo''.
from mesa.time import SimultaneousActivation

plt.rcParams["animation.html"] = "jshtml"
matplotlib.rcParams['animation.embed_limit'] = 2 ** 128

# Importamos los siguientes paquetes para el mejor manejo de valores numéricos.
import numpy as np
import pandas as pd
import random

# Definimos otros paquetes que vamos a usar para medir el tiempo de ejecución de nuestro algoritmo.
import time
import datetime

# TC2008B Modelación de Sistemas Multiagentes con gráficas computacionales
# Python server to interact with Unity via POST
# Sergio Ruiz-Loza, Ph.D. March 2021
import json

def get_grid(model):
    # Obtiene el estado de los diferentes agentes
    # On Param - Model: Modelo con la información
    # On Return - Matriz con información sobre el estado de los agentes
    grid = np.zeros((model.grid.width, model.grid.height))
    for (content, x, y) in model.grid.coord_iter():
        if content == None:
            grid[x][y] = 0
        else:
            grid[x][y] = content.car_model
    return grid


class CarAgent(Agent):
    def __init__(self, unique_id, model, will_stop, lane):
        super().__init__(unique_id, model)
        self.cells_Per_Cycle = 3
        self.car_model = self.random.randrange(50,255)
        self.will_stop=will_stop
        self.count_tilStop=0
        self.end_road = False
        self.will_middle=False
        self.initial_lane = lane

    def moveAgent(self): # Mueve el agente en base a la velocidad que se asigna y si la casilla donde caerá está vacía
        if self.cells_Per_Cycle > 0:
            new_pos=(self.pos[1] + self.cells_Per_Cycle)
            self.is_Out()
            if self.end_road == False:
                if self.model.grid.is_cell_empty((self.pos[0], new_pos)):
                    self.model.grid.move_agent(self,((self.pos[0], new_pos)))
    
    def moveAgentStop(self):
        self.count_tilStop += 1
        if self.count_tilStop < 33:
            self.moveAgent()
        else:
            self.cells_Per_Cycle=0
            neighbors = self.model.grid.get_neighbors(self.pos, moore=True, include_center= False, radius= 5)
            for i in neighbors:
                if i.pos[0]==0 or i.pos[0]==2:
                    if i.pos[1] > self.pos[1]+2:
                        i.cells_Per_Cycle==3
                    elif (i.pos[1] >= self.pos[1]-5 and i.pos[1] >= self.pos[1]-3):
                        i.cells_Per_Cycle==2
                    elif i.pos[1] > self.pos[1]-2 and i.pos[1] <= self.pos[1]+2:
                        i.cells_Per_Cycle==1
    
    def is_Out(self):
        new_pos=(self.pos[1] + self.cells_Per_Cycle)
        if self.model.grid.out_of_bounds((self.pos[0], new_pos)):
            self.end_road = True

    def seek_Obstacle(self):
        neighbor_count_left= 0
        neighbor_count_right= 0
        neighbor_count_center = 0
        is_stopped=False
        new_pos=(self.pos[1] + self.cells_Per_Cycle)
        neighbors = self.model.grid.get_neighbors(self.pos, moore=True, include_center= False, radius= 5)
        for i in neighbors:
            if i.pos[0] == 1 and i.pos[1] > self.pos[1] and i.will_stop==1 and i.cells_Per_Cycle==0: # Identifica si hay un auto detenido frente a self
                is_stopped=True
            if i.pos[0] == 0 and i.pos[1] > self.pos[1]: # Analiza en busca de si hay coches en el carril izquierdo adelante
                neighbor_count_left += 1
            elif i.pos[0] == 2 and i.pos[1] > self.pos[1]: # Analiza en busca de si hay coches en el carril derecho adelante
                neighbor_count_right += 1
        if is_stopped:
            if neighbor_count_left > neighbor_count_right:
                self.model.grid.move_agent(self,((2, new_pos)))
            elif neighbor_count_left <= neighbor_count_right:
                self.model.grid.move_agent(self,((0, new_pos)))
                self.will_middle=True

    def returnAgentmiddle(self): # Parte de la solución del equipo para reducir el tráfico
        new_pos=(self.pos[1] + self.cells_Per_Cycle)
        if self.model.grid.is_cell_empty((1, new_pos)):
            self.cells_Per_Cycle=3
            self.model.grid.move_agent(self,((1, new_pos)))
            self.will_middle = False
        else:
            self.moveAgent()

    def step(self):
        if self.pos[0] == 1:
            self.seek_Obstacle()
        if self.will_stop==1:
            self.moveAgentStop()
        if self.will_stop==0 and not self.will_middle:
            self.moveAgent()
        elif self.will_stop==0 and self.will_middle:
            self.returnAgentmiddle()


class RoadModel(Model):
    # Width: length of the road
    # Height: number or roads
    def __init__(self, width, height, total_frames): # Función que inicializa el modelo
        self.grid = SingleGrid(width, height, False) # False stands for not making the grid a Torus
        self.schedule = SimultaneousActivation(self)
        self.running = True
        self.floor = np.zeros((width,height))
        self.car_Counter = 0
        self.iteration_Counter=0
        self.car_stop = random.randint(120, 180)
        self.active_Cars = []
        self.json = {}
        self.json_array = [None] * total_frames
        self.frame_data = []

        self.datacollector = DataCollector(model_reporters = {"Grid": get_grid})

    def out_of_bounds_identificator(self):
        for agent in self.active_Cars:
            new_pos=(agent.pos[1] + agent.cells_Per_Cycle)
            if(self.grid.out_of_bounds((agent.pos[0], new_pos))):
                self.grid.remove_agent(agent)
                self.schedule.remove(agent)
                self.active_Cars.remove(agent)

    def car_Generator(self, lane): # Función auxiliar que genera nuevos agentes
        if (self.grid.is_cell_empty((lane, 0))): # Si la celda esta vacia, generar el agente al principio de la carretera
            self.iteration_Counter += 1
            if self.iteration_Counter != self.car_stop:
                a = CarAgent(self.car_Counter, self, 0, lane)
                self.grid.place_agent(a,(lane, 0))
            else:
                a = CarAgent(self.car_Counter, self, 1, lane)
                self.grid.place_agent(a,(1, 0))
            self.car_Counter += 1
            self.schedule.add(a)
            self.active_Cars.append(a)


    def build_JSON(self, frame) -> None: # Función que construye el JSON a medida que se van construyendo los autos, genera un objeto de Python
        self.json.clear()
        self.frame_data.clear()
        for agent in self.active_Cars:
            index = {
                "id": agent.unique_id,
                "initial_lane": agent.initial_lane,
                "lane": agent.pos[0],
                "track_completion": agent.pos[1],
                "speed": agent.cells_Per_Cycle
            }
            if(len(self.frame_data)!=0):
                for car in self.frame_data:
                    carFound = False
                    if (agent.unique_id == car["id"]):
                        self.frame_data[agent.unique_id] = index
                        carFound = True
                        break
                if not carFound:
                    self.frame_data.append(index)
            else:
                self.frame_data.append(index)
        self.json_array[frame] = self.frame_data
        self.json["DataSet"] = self.json_array
        

    def getJSON(self): # Función que convierte el objeto de Pyton en un JSON
        return json.dumps(self.json)

    def step(self,frame):
        print(frame)
        lane = self.random.randint(0, 2) # Genera aleatoriamente el carril donde iniciará el auto
        self.car_Generator(lane) # Genera el auto
        self.datacollector.collect(self) # Inicia la recolección de datos
        self.out_of_bounds_identificator()
        self.schedule.step() # Activa los agentes
        self.build_JSON(frame) # Genera el JSON.


# Definimos el tamaño del Grid
WIDTH = 200  # Longitud de Carriles
HEIGHT = 3  # Carriles

# Definimos el número máximo de generaciones a correr
MAX_GENERATIONS = 300

# Registramos el tiempo de inicio y ejecutamos la simulación
start_time = time.time()
model = RoadModel(HEIGHT, WIDTH, MAX_GENERATIONS)
for i in range(MAX_GENERATIONS):
    model.step(i)

# Imprimimos el tiempo que le tomó correr al modelo.
print('Tiempo de ejecución:', str(datetime.timedelta(seconds=(time.time() - start_time))))

# Se recupera la información del colector, regresa un Dataframe con la información
all_road = model.datacollector.get_model_vars_dataframe()


# Start API
app = Flask(__name__)


@app.route('/data')
def get_car_data():
    data = model.json
    return data


if __name__ == "__main__":
    app.run(debug=True)
